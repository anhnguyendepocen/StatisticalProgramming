0. Announcements and projects.1. Logistic regression in R.2. Nonlinear regression in R.3. C++ in R.0. Announcements and projects.2 sample projects are on the course website, just to give you examples.Don't follow them closely, but notice the enthusiasm, the attention to details,the identification of outliers, and the interpretation of results.What might be a great idea for your project is to take some regressionstyle data, fit a generalized additive model by kernel regression (and/orperhaps fitting terms that look linear or quadratic by linear or quadraticfunctions), and using C to get confidence intervals for your fitted curves.1. Logistic regression in R.Suppose your response variable Y is 0 or 1 for all observations.Normally for a regression model, Y = X beta + epsilon,where the epsilons are iid normal with mean 0, which is obviously unreasonable here since Y is always 0 or 1.So instead it makes more sense to model P(Y=1) = X beta + epsilon,but that has problems because X beta + epsilon can be negative, or > 1.By the way, by X beta I am thinking of X as a matrix where the first columnis all 1's, and each other column is a covariate, and there are p-1 covariates, andbeta = (beta_0, beta_1, ..., beta_{p-1}).Thus X beta = beta_0 + beta_1 X_1 + beta_2 X_2 + ... + beta_p X_{p-1}.So, instead of modeling P(Y=1) = X beta + epsilon,one models p = P(Y = 1), via X beta = f(p), or equivalently p = f^{-1}(X beta), where f is called a link function.Note by the way that when Y is 0 or 1, E(Y) = P(Y = 1).So we could also write this as E(Y) = f^{-1}(X beta).Often people use the logistic function, f^{-1}(x) = exp(x)/[1+exp(x)],and this corresponds to logistic regression.Here E(Y) = e^{X beta} / [1 + e^{X beta}].Regardless of X beta, f^{-1}(X beta) will then be between 0 and 1.The link then is the logit function, i.e.X beta = f(p) = log{p/(1-p)}.log(p/(1-p)) is called the log odds ratio.The logistic regression model is that the Y's are independent Bernoulli(p) random variables, where the vector p = e^{X beta} / [1 + e^{X beta}].Logistic regression is an example of Generalized Linear Modeling (GLM),where one models g(E(Y)) = X beta for some link function g,and where Y has some modelled distribution.  #install.packages("UsingR")  library(UsingR)  data(babies)This dataset accompanies Stat Labs: Mathematical Statistics through Applications Springer-Verlag (2001) by Deborah Nolan and Terry Speed, see www.stat.berkeley.edu/users/statlabs/labs.html .  babies[1,]  bab2 = subset(babies, subset = gestation < 999 & wt1 < 999 &                 ht < 99 & smoke < 9 & age < 99 & number < 98)  ## A baby is considered premature if the gestation < 37 weeks.  prem = as.numeric(bab2$gest < 37*7)  smoke = as.numeric(bab2$smoke > 0)  weight = bab2$wt1 ## mother's weight at conception  height = bab2$ht ## mother's height  age = bab2$age ## mother's age  num = bab2$number ## baby number  bmi = weight/2.2 / (height*.0254)^2  hist(bmi,nclass=20)  fit1 = glm(prem ~ smoke + age + bmi, family = binomial)  summary(fit1)Coefficients:             Estimate Std. Error z value Pr(>|z|)   (Intercept) -3.610895   0.820464  -4.401 1.08e-05 ***smoke        0.205526   0.217915   0.943    0.346   age          0.008197   0.018269   0.449    0.654   bmi          0.038270   0.030897   1.239    0.215   ---Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1## nothing is significant, but the estimate for smoking is large.## According to the fitted model,## log odds increase by 0.2055 because of smoking.  mean(prem)  ## 0.082, so a typical birth has probability 8.2% of being premature.  mean(prem[smoke==0]) ## 7.4%  mean(prem[smoke>0]) ## 8.7%How can we interpret this 0.2055?  p = 0.082  q = 1-p  log(p/q) ## -2.415478  ## so log odds for typical birth are -2.415.  ## Now add .2055.  r = -2.415 + .2055  exp(r)/(1+exp(r))## 9.9%.## so a typical woman's chance of premature delivery is 8.2%, and## according to the model, changing her from a nonsmoker to smoker## would increase this to 9.9%.## But beware of inferring causation. And the coef is not stat. sig.You can also fit more complex models and pick the best fitting by minimizing AIC.  fit1 = glm(prem ~ (smoke + age + num + bmi)^2, family = binomial)  summary(fit1)  library(MASS)  stepAIC(fit1)2. Nonlinear regression in R.Instead of Y = X beta + eps, what if you want to fit Y = f(x) + eps?You might have, for instance, an exponential relationship between Y and X, likeY_i = beta_0 e^{beta_1 x_i} + epsilon_i.You can use nls() in R to fit such models.fit1 = nls(formula, start = ..., trace = FALSE).The model formula is a little different in nls() than in lm().Again you use y ~ mean, but you express mean using ordinary math notation. For instance, you can do y ~ n * exp(-b*(t-t0)), where t is your data and n,b, and t0 are parameters to be estimated. It's often nice to write your own function f to compute the mean, and then you can just write the formula as y ~ f(t,n,b,t0).nls() works by starting at some initial guess of the parameter values, stored in start =- ..., ideally somewhat close to the true values. It then moves around in each direction using Newton-Raphson type methods til it finds the smallest sum of squared residuals it can.trace = TRUE is useful if you want to see each step, and FALSE is the default.You can sometimes find reasonable starting values using curve(, add=TRUE).Yellowfin tuna example.  library(UsingR)  data(yellowfin)  number = yellowfin$count  yr = yellowfin$year  plot(yr,number)  f = function(t,n,r,d){    n * (exp(-r*(t-1952))*(1-d) +d)  }  curve(f(x, n=6, r = 1/10, d=.1),add=T,col="BLUE")  fit1 = nls(number ~ f(yr,n,r,d), start=c(n=6,r=1/10,d=.1))  fit1  par1 = summary(fit1)$par[,1]  curve(f(x,par1[1],par1[2],par1[3]),add=T,col="RED")  legend("top",legend=c("initial","fitted exp."),lty=c(1,1),    col=c("BLUE","RED"))3. C++ in R.This is based on Hadley Wickham's notes on Rcpp,http://adv-r.had.co.nz/Rcpp.html . See alsohttp://www.learncpp.com and http://www.cplusplus.com .Typical bottlenecks that C++ can address include:Loops that canÍt be easily vectorised because subsequent iterationsdepend on previous ones.Recursive functions, or problems which involve calling functionsmillions of times. The overhead of calling a function in C++ is much lower than that in R.Problems that require advanced data structures and algorithmsthat R doesnÍt provide. Through the standard template library (STL), C++ has efficient implementations of many important data structures, from ordered maps to double-ended queues.Unlike C, we will be writing, compiling and running C++ code inside R,using Rcpp and cppFunction. Here is a simple example.  ## install.packages("Rcpp")    library(Rcpp)  cppFunction('int add(int x, int y, int z) {  int sum = x + y + z;  return sum;  }')  add(1,5,2)As with C, You must declare the type of output the function returns. This function returns an int (a scalar integer). The classes for the most common types of R vectors are: NumericVector, IntegerVector, CharacterVector, and LogicalVector.Scalars and vectors are different. The scalar equivalents of numeric, integer, character, and logical vectors are double, int, String, and bool.Each vector type has a matrix equivalent,NumericMatrix, IntegerMatrix, CharacterMatrix, and LogicalMatrix. Using them is straightforward.Like C, you must use an explicit return statement to return a value from a function, andyou have to use = for assignment, not <-.In C++, loops are much faster than in R.  mymean = function(x){  y = 0  n = length(x)  for(i in 1:n){      y = y + x[i]      }  y/n  }Now here it is in C++.  cppFunction('double mymeanC(NumericVector x) {  int n = x.size();  double total = 0;  for(int i = 0; i < n; ++i) {    total += x[i];  }  return total / n;}')  x = runif(10000000)  mymean(x)  mymeanC(x)To find the length of the vector, we use the .size() method, which returns an integer. C++ methods are called with .Note that we could say int i inside the for loop declaration.You can't do this in traditional C, but in C++ it's ok.Now here is an example with vector input and vector output.Suppose we want a function to compute the squared difference from a particular number x and a vector y.In R it is simple.  pdiffR = function(x, y) {    (x - y) ^ 2  }In C++ it would be more complex but twice as fast.  cppFunction('NumericVector pdiffC(double x, NumericVector y) {    int n = y.size();    NumericVector out(n);    for(int i = 0; i < n; ++i) {      out[i] = pow(y[i] - x, 2.0);    }    return out;  }')x = 3.2y = 1:10pdiffR(x,y)pdiffC(x,y)Matrices are dealt with just as in C, but in C++, you subset a matrix with (), not [].  cppFunction('NumericVector rowSumsC(NumericMatrix x) {    int nrow = x.nrow(), ncol = x.ncol();    NumericVector out(nrow);    for (int i = 0; i < nrow; i++) {      double total = 0;      for (int j = 0; j < ncol; j++) {        total += x(i, j);      }      out[i] = total;    }    return out;  }')  x = matrix(1:100, ncol=10)  rowSums(x)  rowSumsC(x)You can use .nrow() and .ncol() methods to get the dimensions of a matrix.## SIMPLE EXAMPLE OF OBJECT ORIENTED SYNTAX IN C++.From https://www3.ntu.edu.sg/home/ehchua/programming/cpp/cp3_OOP.html  cppFunction('int add1(int n) {/* The Circle class (All source codes in one file) (CircleAIO.cpp) */#include <iostream>    // using IO functions#include <string>      // using stringusing namespace std; class Circle {private:   double radius;      // Data member (Variable)   string color;       // Data member (Variable) public:   // Constructor with default values for data members   Circle(double r = 1.0, string c = "red") {      radius = r;      color = c;   }    double getRadius() {  // Member function (Getter)      return radius;   }    string getColor() {   // Member function (Getter)      return color;   }    double getArea() {    // Member function      return radius*radius*3.1416;   }};   // need to end the class declaration with a semi-colon    // Construct a Circle instance   Circle c1(1.2, "blue");   cout << "Radius=" << c1.getRadius() << " Area=" << c1.getArea()        << " Color=" << c1.getColor() << endl;    // Construct another Circle instance   Circle c2(3.4); // default color   cout << "Radius=" << c2.getRadius() << " Area=" << c2.getArea()        << " Color=" << c2.getColor() << endl;    // Construct a Circle instance using default no-arg constructor   Circle c3;      // default radius and color   cout << "Radius=" << c3.getRadius() << " Area=" << c3.getArea()        << " Color=" << c3.getColor() << endl;   return 0;}')  add1(1)Coming up.## Maximum likelihood estimation in C and R.## Building R Packages.## More C++.