1. Hw etc.2. R Cookbook ch1-4, continued.3. R Cookbook ch5.4. R Cookbook ch6.1. HW2, etc.We will talk about kernel smoothing next week.Read up through ch7 in R Cookbook.Loading in the housing data.I took out the first line about the overrall county, I removed spaces from the city names, and I removed $s, %s, and ,s.  x = read.table("LAhousingpricesaug2013.txt",header=T)   ## after removing spaces,etc.  y = as.numeric(as.vector(x[,3]))  x1 = as.numeric(as.vector(x[,4]))  x2 = as.numeric(as.vector(x[,7]))  x3 = as.numeric(as.vector(x[,9]))  z = !is.na(y+x1+x2+x3)  yy = y[z]  x11 = x1[z]  x22 = x2[z]  x33 = x3[z]  Alternatively,  x = scan("LAhousingpricesaug2013.txt",skip=1,what="char",sep=",")  z = matrix(x,ncol=9,byrow=T)  y = as.numeric(z[,3])  x1 = as.numeric(z[,4])  x2 = as.numeric(z[,7])  x3 = as.numeric(z[,9])  z1 = (!is.na(y) & !is.na(x1) & !is.na(x2) & !is.na(x3))  myy = y[z1]  myx1 = x1[z1]  myx2 = x2[z1]  myx3 = x3[z1]2. R Cookbook ch1-4, continued.##### READING IN DATA FROM FILES.read.table() was illustrated above.scan() is extremely useful and more robust than read.table() in thatthe data inputted do not need to be rectangular, i.e. you do not needa set number of elements in each row of the data.read.csv() p81 and readHTMLTable() p84 do not work well in my experience. Same with dbConnect() on p90.The example on p88 and 89 about scan() is definitely worth reading, and also illustrates the use of order(). Save perm = order(world.series$year) so that you can keep year and pattern in the same order as each other.##### EXTRACTING ELEMENTS OF A LIST.Note that for a list, like world.series on p89, you use the $ key to get one element of the list. For instance,     x = list(a = c(1:3), b = rep(5,7))  x$a  x$bYou can also do x[[1]] or x[[2]] to get the first or 2nd objects in a list.p91 illustrates the useful function paste(), which merges character strings and numeric objects.   x = 1  y = 3.4  z = paste("The answer to problem",x,"is",y,".")  cat(z)## Note that paste adds a space between elements by default. ## You can change sep to "" to change this.     z = paste("The answer to problem",x,"is",y,".",sep="")  cat(z)You can extract part of a character string using substr().  substr(z,5,10)  a = "abcdefghij"  substr(a,3,5)## Done with Chapter 4.3. Chapter 5 of R Cookbook.###### MANIPULATION OF LISTS IN R.As mentioned above, you do x[[1]] or x[[2]] to get the first or 2nd objects in the list x.As described in p96 of Teetor, x[[2]] = the 2nd element of a list x, while x[2] yields a list containing the 2nd element of x. The single bracket outputs a list. See pp 110-111 for more on this.  ##### PRINT() AND DIFFERENT DATA TYPES.p 97, print(x) outputs different things depending on what x is. p98 gives an example of printing a vector and a matrix.For 3-d arrays, use dim(). See p99.    D = 1:12  dim(D) = c(2,3,2)  print(D)  D[1,2,1] ## note that the output is 3, not 2. Data frames, p 100. Basically a table of typical regression-type data.Similar to a list.##### THE RECYCLING RULE.The recycling rule is described on p103 of Teetor. When the shorter vector is done, R goes back to its beginning, recycling its elements.    x = 1:6  y = 1:3  x + yAs noted on p105, when x is a vector and y is a scalar, x+y is just a special case of the recycling rule.p106 gives examples of factors, for categorical variables.##### MORE MANIPULATION OF LISTS.p107, stack() seems useful, to combine your data into 2 big vectors.    x = runif(2); y = rnorm(4); z = rexp(2)  w = stack(list(uniform = x, normal = y, exponential = z))  wp114, use NULL to remove an element of a list.    w = list(x = 1:2, y = rnorm(4), z = 3:4)  w  w$y = NULL  wp115, unlist() takes a list and makes it into a big vector.    cat(w) ## doesn't work on lists.  w2 = unlist(w)  cat(w2)##### MANIPULATION OF MATRICES.p118, matrix()    m = matrix(w2, 2, 2)  mNote that by default, the elements are read in column by column.  m2 = matrix(w2, 2, 2, byrow=T)  m2p119-120, some matrix operations.   t(m) ## transpose.  m %*% m2 ## matrix multiplication.  m * m2 ## element by element multiplication.  solve(m) ## inverse  diag(m) ## diagonal  help("%*%")p120, rownames() and colnames().    rownames(m) = c("ORANGE", "brown")  colnames(m) = c("YELLOW","white")  m  m2##### DATAFRAMES.p122, data.frame() to create a new dataframe from vectors and factors,and as.data.frame() to coerce a list or matrix into a dataframe.p124 describes how to get a list of rows of data into one data frame, using    y = do.call(rbind, x)This is when x is already a list of dataframes.Also, on p125 Teetor says how to get a list of lists into one data frame, using Map().  y = do.call(rbind, Map(as.data.frame, x))Map(as.data.frame, x) takes your list x of lists and makes it a list of data frames, and then do.call(rbind, ...) takes this list of dataframes and binds them into one big dataframe. If this stuff is confusing to you, don't worry about it. In my experience it very rarely comes up.p127 describes getting a subset of a dataframe. It's similar to lists.  x[[n]] gets the nth column, and x[n] returns a dataframe consisting of the nth column. pp128-129 give a nice example.  names = c("abigail", "barbara", "carl", "david")  location = c("westwood", "santa monica", "venice", "palms")  status = c("undergrad", "phd", "masters", "undergrad")  grade = c(1,2,3,4)  x = data.frame(names, location, status, grade)  x  x$grade ## the 4th column, as a vector  x[[4]] ## the same thing  x[4] ## a dataframe consisting only of the 4th vector  x[c(1,2,4)] ## the same as x without the 3rd column.  x[[c(1,2,4)]] ## error##### FUNCTIONS ON MATRICES AND DATAFRAMESmean(x)Computes the overall mean of all entries for a matrix,but computes the column means for a data frame.  x = matrix(1:10,ncol=2)  mean(x)  y = as.data.frame(x)  mean(y)To compute row means or column means of a matrix, you can use colMeans() or apply().  colMeans(x)  apply(x,2,mean)## The "2" means you're going column by column. See p151. For row means you would do  apply(x,1,mean)apply() works on data frames the same way.  apply(y,1,mean)  apply(y,2,mean)There is also rowMeans(x).p136, na.omit() is interesting. It removes the ROWS with NAs.Any row with any NA in any entry gets removed.  x = data.frame(height=c(61,67,72,70), shoes = c(3,2,1,3))  x  mean(x)  x[3,2] = NA  x  mean(x) ## returns NA for shoes.  y = na.omit(x)rbind() and cbind() are extremely useful, pp138-139.  z = cbind(names,x,status,grade)  z1 = c("ed",71,3,"undergrad","A")  z1 = rbind(z,z1) ## doesn't work  z2 = data.frame(names="ed",height=71,    shoes=3,status="undergrad",grade="A")  newz = rbind(z,z2) ## If the names don't match, it won't work.  colnames(z2)[3] = "shoes"  newz = rbind(z,z2)p140, merge() combines two dataframes with the same entries in one column. Note that the the rows (like "Larry" in the example on p140) in one dataframe but not the other get removed by default.with() on p141 is kind of silly. You might as well use attach(), p142, to compute something on a subset of a dataframe. But watch out when changing an element of a dataframe after detaching it! See pp 142-143.  z2 = data.frame(names="ed",height=71,shoos=3,status="undergrad",grade="A")  attach(z2)  shoos  detach(z2)  shoos ## now shoos is gone  attach(z2)  shoos = 0  shoos  z2$shoos ## hasn't changed.  z2pp144-145 show how to change modes. Kind of useful.6. R Cookbook ch. 6.##### FACTORS.Teetor p147 describes factors. A factor is a group of elements taking values in different levels.split, p148, divides the elements into groups, in a list.    x = c(1,4,1,8,9,4,1)  fa = factor(c("b","a","b","a","c","b","c"))  y = split(x,fa)or  y = unstack(data.frame(x,fa))if the resulting vectors have the same length, unstack() makes the result a data frame, rather than a list.  x = c(1:10)  fa = factor(c("a","b","c","d","e","a","b","c","d","e"))  y = unstack(data.frame(x,fa))##### DIFFERENT TYPES OF APPLY().p149, lapply and sapply useful for applying a function to every element of a list.sapply returns a vector or matrix if possible, whereas lapply always returns a list.  x = list(a=1:4, b=c(2,2,3,5), c=4:9)  y = apply(x, mean) ## error, because x is a list rather than a matrix.  y = lapply(x, mean)  z = sapply(x, mean)  z = sapply(x, t.test) ## returns a list, because t.test returns a list.  z2 = lapply(x, t.test)Teetor on the bottom of p150 says you NEED to use lapply() here, because t.test() returns a list. However, sapply() works, though it coerces everything into a list of individual elements, whereas lapply makes it a list of 3 short lists.  z[1]  z2[1]So the book's example is   tc2 = function(a){     b = t.test(a)     b$conf.int     }  z3 = sapply(x, tc2)or, as in the book's example on p151,  z3 = sapply(z2, function(t) t$conf.int)  foo = function(t){ ## t is a list    t$conf.int  }  ## or equivalently  foo = function(t) t$conf.int   z3 = sapply(z2, foo)p152, for a dataframe, lapply() and sapply() work on columns by default. lapply() returns a list, and sapply() a vector.  z3 = data.frame(z3)  z4 = lapply(z3, mean)  z5 = sapply(z3,mean)Teetor on p153 gives a nice example of the real use of sapply in cors = sapply(pred, cor, y=resp).It goes column by column in the dataframe pred of predictors, calculating the correlation of each predictor with the response.y=resp is passed as an argument to cor().Here's an example of how you can pass arguments within sapply.Suppose you want to take each element, raise it to the u power,and sum up the elements.   x = data.frame(matrix(1:6,ncol=3))   f2 = function(t, u = 3){  sum(t^u)  }  y = sapply(x, f2)  y2 = sapply(x, f2, u=2)You can also do  y3 = sapply(x, f2, 2)pp154-155, use tapply() to apply a function to each subgroup of your data.The functions used in apply(), sapply(), and lapply() must operate on vectors. If instead you want to apply a function that operates on dataframes, such as print(), then use by() instead. See pp 156-157.pp158-159, if a function only works on scalars, not vectors, such as the greatest common denominator function gcd() on p158, then use mapply().  gcd = function(a,b){     if(b==0) return(a)     else return(gcd(b, a %% b))  }  ## a %% b = a mod b  gcd(40,16)  x = c(1,2,3)  y = c(9,6,3)  gcd(x,y)  mapply(gcd,x,y) returns [1] 1 2 3because 1 is the gcd of (1,9), 2 is the gcd of (2,6), and 3=gcd(3,3).For a different example,    f2 = function(a,b){      if(a>b) return("1st is bigger")      if(a==b) return("Equal")      else return("2nd is bigger")  }  f2(7,8)  f2(8,7)  f2(c(1,4,2),c(3,2,2))  x = c(1,4,2.5)  y = c(3,2,2.5)  mapply(f2,x,y)## Done with ch6.## Next time, check C compiler?