1. Teams and admin.2. R Cookbook ch. 9.3. R Cookbook ch. 10.1. Teams for final projects and other administrative things.You must work independently for all 4 homeworks!Read through ch11 for next class.I will randomly assign you to groups of 2-3 students, and you will analyze some data using the methods we have talked about in class, including the methods used for the homeworks and also other methods we have discussed in class. Your group will write up your analysis in a written report, and the group will also make an oral presentation, where every member of your group will speak. The oral presentations will be 8-10 minutes each in total. You will be graded on the performance of your group, rather than individually, and each group will receive one overall grade based on the oral report and written report, combined. This combined grade will count for 15% of your overall grade in the class, and the other 85% will be based on your homework assignments.Your dataset, which you will find yourselves, on the web,can be anything you choose, but it should be:a) regression style data, i.e. a response variable, and for eachobservation, a bunch (at least 2 or 3) explanatory variables. You shouldhave at the very least n=30 observations.b) something of genuine interest to you.Analyze the data using the methods we have talked about in class,such as linear regression, univariate kernel density estimation, 2-d kernel density estimation, statistical testing, quantile plots, and kernel regression.At least one component of your data anlysis should be done in C. Your final project should be submitted to me in pdf by email to frederic@stat.ucla.edu by Sun Dec 14, 11:59pm. Note the address. Do not send them via ccle.Obviously, you only need to send one per group. They are all due the same date, regardless when your oral presentation is.I will now randomly assign people to groups.First, add any missing names to roster.txt.If you want to change oral presentation dates and times with another group, feel free but let me know.I will use sample(), which randomly permutes the elements of a vector.  a = c("a","b","c","d")  sample(a)  mygroups1 = function(){    x = scan("roster.txt",what="char",sep="\n")    n = length(x)    y = sample(x)    fl = floor(n/2)    for(i in 1:fl){      if(i == 1)  cat("\n\n  Thu, Dec 4\n")      if(i == 8) cat("\n\n  Tue, Dec 9 \n")      if(i == 15) cat("\n\n  Thu, Dec 11 \n")      cat(i,". ",sep="")      for(j in 1:2) cat(y[2*(i-1)+j],".      ")      if(i == 20) cat(y[n],".\n")        cat("\n")      }    }  mygroups1()!!! PLEASE FIND YOUR TEAMMATES AFTER CLASS !!!  Thu, Dec 41. LANIYONU, AYOBAMI STEPHEN .      ZHAO, YIBIAO .      2. CHOPRA, AKSHIT .      HUDLI, SHRINIDHI RAGHU .      3. RAZAEE, ZAHRA .      YU, XIAOLU .      4. KAMATH MANJESHWAR, AASHITH .      HU, XUE .      5. MEHRISH, RAGHAV .      SOSA, LUIS ANTONIO .      6. GAO, MEI .      QIU, WEICHAO .      7. LI, WEI .      JACOBSON, THOMAS ABRAM .        Tue, Dec 9 8. AHLUWALIA, PUNEET SINGH .      KUMAR, PRAPHULL .      9. BLACKBURN, TIMOTHY .      PATEL, RIKI .      10. PERITZ, LAUREN J .      KAPUR, SHIVIN .      11. KRISHNAMOORTHY, LAKSHMAN .      SHU, TIANMIN .      12. ZHANG, DACHENG .      MIN, SEUNGHYUN .      13. DUNN, BRETT RADCLIFFE .      BHATKHANDE, ASHWINI ASHOK .      14. CHEN, XUHUI .      RUSKIN, AMY SOFIA .        Thu, Dec 11 15. DALVI, HARSHAL GANESH .      NOH, YUREE .      16. VERMA, ANKUSH .      HO, MINH .      17. CHEN, LIULI .      HE, CENLIN .      18. HILL, MITCHELL KRUPIARZ .      YANG, JI .      19. FAN, WEIKANG .      YU, JINGZHI .      20. MINOCHA, AYUSH ARUN .      FARRUKH, ADINA .      LIU, YANG .Attendance will be mandatory the last 3 classes of the quarter.2. R Cookbook ch9.#### SAMPLING WITH DIFFERENT SIZES AND WEIGHTED SAMPLING.If you want to generate 3 samples of different sizes from the vector 1:10, you could do  y = c(5,4,2)  x = list()  for(i in 1:3){    x[[i]] = sample(1:10,y[i])  }You can also have sample choose elements with different probabilities, by giving it as an argument a vector of probabilities, as on p185.    sample(1:10, 50, rep=T, prob = (1:10)/55)#### SORTING AND DIFFERENCING.p187, diff() calculates the differences between successive elements of a vector. It returns a vector of length n-1, if your initial vector had length n. Note that when your vector is a list of times, often you want to sort your vector before using diff().    t = rpois(10, lambda=20)  diff(t)  t1 = sort(t)  t1  diff(t1)#### PLOTTING DENSITIES.pp 191-192 show an interesting example of plotting densities. He calculates the density on a vector x of points all at once.    dnorm((1:10)/10)We can do this with the exponential distribution.    x = seq(0,10,length.out=100)  y = dexp(x)  plot(x,y, main="Exponential distribution", type="l",    ylab="density", xlab="value")Note that he uses the polygon() function to shade in a region. region.x consists of all the x-coordinates of the region.region.y consists of all the y-coordinates of the region.    x1 = x[1 <= x & x <= 3]  region.x = c(min(x1), x1, max(x1)) ## Teetor uses x1[1] and tail(x1,1) instead of min() and max()   y1 = y[1 <= x & x <= 3]  region.y = c(0,y1,0)  polygon(region.x, region.y, col="blue", density = 20)##### RELATIVE FREQUENCY.p199, mean(x > 0) computes the relative frequency, because (x > 0) is a vector of TRUEs (1) and FALSEs (0).    y = runif(50000)  mean(y > 0.8)##### CHI SQUARE TEST.p200 describes table(), which we've seen before. p201, summary(table) does a chi square test forindependence between 2 factors. A small p-value indicates statistically significant dependence, i.e. strong evidence against the assumption of independence.  shy = factor(c(rep("Y", 23), rep("N",20)))  gpa = factor(c(rep("A",10), rep("B", 10), rep("C",10), rep("A", 2),      rep("C", 2), rep("B", 9)))  table(shy)  table(gpa)  table(shy,gpa)  summary(table(shy, gpa))##### NORMALIZATION.p203, scale() normalizes a numerical vector, matrix, or data frame.    x = c(1,2,4,4,3)  y = scale(x)  y[1:5]##### T TEST.p203-204, t.test() to test against a null hypothesis of the mean, or to get a confidence interval for the population mean.    t.test(x, mu=1)  t.test(x, conf.level = 0.975)  y = t.test(x, conf.level = 0.975)  attributes(y)  y$conf.int  y$conf.int[1:2]##### WILCOXON TEST, PROPORTION TEST, AND SHAPIRO TEST.p206, wilcox.test(x, conf.int=TRUE) ## CI for the median    x = c(1:10,-7.1,20)  wilcox.test(x, conf.int=TRUE)p207, testing if the population proportion of successes = some null hypothesis value. Say you have 70 successes out of 97 trials, and your null hypothesis is that p = 0.80.    prop.test(70,97,0.8)You can use this too to get a CI for p.  prop.test(70,97,0.8, conf.level = 0.9)Test for normality.  shapiro.test(x)p210, in the nortest package are more tests for normality.##### TESTING FOR STREAKS IN TS DATA.p211, testing if the total number of runs, or streaks, or equivalently changes, in binary time series data, is significantly different from what you'd expect by chanceif the observations are iid,using runs.test().    install.packages("tseries")  library(tseries)  x = runif(50)  y = (x > 0.4)  runs.test(as.factor(y))    x = sample(c(0,1,2),50,rep=T)  runs.test(as.factor(x)) ## error because the data are not binary.##### COMPARISON OF SAMPLE MEANS.p212, t.test() to test if the difference between two sample means is statistically significant.    x = runif(400)  y = rnorm(70000, mean=.57)  t.test(x,y)By default, paired = FALSE, but if you have paired data andx and y have the same length you can say  t.test(x,y[1:400],paired = TRUE)p214, an alternative is the nonparametric Wilcoxon-Mann-Whitney test,where you calculate the sum of the ranks of values of x in the vector c(x,y), and compare with what you'd expect if the two distributions were equivalent.  wilcox.test(x,y)##### PEARSON TEST.p215, Pearson test to see if a correlation is statistically significant.x and y must have the same length.  x = runif(200)  y = 0.8*x^2 + rnorm(200)  plot(x,y,main=expression(y[i] == 0.8 * x[i]^2))  cor.test(x,y)  abline(lsfit(x,y))Equivalently, you can fit a line by regression and use the t-test on the coefficient for y.    b = lm(y ~ x)  ## similar to b = lsfit(x,y)  summary(b)  abline(b)  attributes(b) They're the same.    summary(b)$coef[8]  cor.test(x,y)$p.valueThe book also discusses prop.test() on p217, for comparing two proportions,pairwise.t.test() on p218, for comparing the means of > 2 samples,and the Kolmogorov-Smirnov test ks.test() to see if two cumulative distribution functions might be equivalent.3. R Cookbook ch10.##### PLOTTING FUNCTIONS.p222, list of plotting functions, such as plot(), boxplot(), and hist().p225, the main = "my title" argument in plot creates a title.    x = runif(10)  y = rnorm(10)  plot(x,y,xlab="uniforms", ylab="normals", main="Figure 1")p226, grid() makes it like graph paper.  grid()  grid(col=grey(.1))p227, pch is a useful argument to plot. We've seen pch="." for small points. You can give pch a vector and it will plot each point differently.cex controls the size of the characters.    names = c("a","b","c","d","e","f","g","h","i","j")  plot(x,y,pch=names,cex=1.5)  plot(x,y,pch=".",cex=5)When pch takes a number, it plots a symbol, with 1 = circle, 2 = triangle, 3 = plus, etc.  types2 = c(rep(1,5),rep(2,3),rep(3,2))  plot(x,y,pch=types2)If you want it to plot the index of your data, you have to make the indices characters.  names = as.character(1:10)  plot(x,y,pch=names) ## note that number 10 gets cut off.  plot(x[1:9],y[1:9],pch=names[1:9])text works better for this.  plot(x,y,type="n")  text(x,y,names)Use points() to overlay symbols.  points(x,y,pch=types2) ## looks bad.  plot(x,y,type="n")  text(x-.05,y,names)  points(x,y,pch=types2,col="red",cex=2)You might want to make the yaxis intersect 0.Use the argument xaxs = "i" and yaxs = "i" in plot().   x = c((0:10)/10)  y = x  plot(x,y,type="l")  plot(x,y,type="l",yaxs="i")  plot(x,y,type="l",xaxs="i",yaxs="i")  plot(x,y,type="l",xlim=c(0.1,.9),ylim=c(0.1,.9),xaxs="i",yaxs="i")Legend, p229.    legend(0.5, .6, c("shoes", "socks", "hats"), lty=c(1:3),cex=.8,col=c("red","blue","green"))legend("topright", c("shoes", "socks", "hats"), lty=c(1:3),cex=.8,col=c("red","blue","green"))You can use "lty" in place of "pch" above. See p230. Note that this is NOT the kind of legend I want you to do for hw2 in problem 1e.barplot() p236, abline() p245, boxplot() p247, and hist() p249 are self-explanatory.p244 shows a common mistake when plotting two curves on the same plot.You have to set the ranges first so that both curves fit.p253, qqnorm(), qqline()    x = rt(500,df=4)  ## generate 500 draws from the t_4 distribution.  hist(x, nclass=40, main = "")  qqnorm(x)  qqline(x)To make other types of quantile plots, see p255.  plot(qt(ppoints(x),df=4),sort(x))  abline(a=0,b=1)