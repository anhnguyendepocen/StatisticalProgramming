0. Misc.1. Projects.2. Vectors and matrices in C.3. Calling C functions from C.4. Running C from terminal.5. Reading in from a file in C.0. Misc.NO CLASS or OH TUE NOV 11, for Veteran's Day.Final projects.   Thu, Dec 41. LANIYONU, AYOBAMI STEPHEN .      ZHAO, YIBIAO .      2. CHOPRA, AKSHIT .      HUDLI, SHRINIDHI RAGHU .      3. RAZAEE, ZAHRA .      YU, XIAOLU .   BINGLING WANG. *** 4. KAMATH MANJESHWAR, AASHITH .      HU, XUE .      5. MEHRISH, RAGHAV .      SOSA, LUIS ANTONIO .      6. GAO, MEI .      QIU, WEICHAO .      7. LI, WEI .      JACOBSON, THOMAS ABRAM .        Tue, Dec 9 8. AHLUWALIA, PUNEET SINGH .      KUMAR, PRAPHULL .      9. BLACKBURN, TIMOTHY .      PATEL, RIKI .      10. PERITZ, LAUREN J .      KAPUR, SHIVIN .      11. KRISHNAMOORTHY, LAKSHMAN .      SHU, TIANMIN .      12. ZHANG, DACHENG .      MIN, SEUNGHYUN .      13. DUNN, BRETT RADCLIFFE .      BHATKHANDE, ASHWINI ASHOK .      14. CHEN, XUHUI .      RUSKIN, AMY SOFIA .        Thu, Dec 11 15. DALVI, HARSHAL GANESH .      NOH, YUREE .      16. VERMA, ANKUSH .      HO, MINH .      17. CHEN, LIULI .      HE, CENLIN .      18. HILL, MITCHELL KRUPIARZ .      YANG, JI .      19. FAN, WEIKANG .      YU, JINGZHI .      20. MINOCHA, AYUSH ARUN .      FARRUKH, ADINA .      LIU, YANG .Rgooglemaps package is nice for adding maps to plots, by the way.For compiling C in Windows, these links might be useful:http://mcglinn.web.unc.edu/blog/linking-c-with-r-in-windows .http://www.stat.columbia.edu/~gelman/stuff_for_blog/AlanRPackageTutorial.pdf .http://cran.r-project.org/bin/windows/baserw-FAQ.html#How-do-I-include-compiled-C-code_003f .Note on hw4: When I say in hw4 problem 2d "sample 100 pairs of observations (Xi, Yi) with replacement," I mean, if your dataset has length n, then let  b = sample(1:n, 100, rep=T)and for each element i in b,take (Xi, Yi).1. Final project and oral report tips.For the oral projects.Rule 1: Do not look at me when you are talking!Rule 2: 8-10 minutes per oral report and everybody in the group must speak for roughly equal amounts. I will cut you off if your group goes over. You can have someone in the audience or on your team helping you with the time.Rule 3: Everyone must be respectful and quiet during other people's talks. No questions because we won't have time.Rule 4: Send me a pdf or powerpoint version of your group's slides by 6pm the night before your talk, to frederic@stat.ucla.edu. That way, I can set up the talks in order ahead of time and we won't have to waste time in class waiting for each person to connect their laptop to the projector. About 7 or 8 slides seems right, though it's fine with me if you want fewer or more.Rule 5: Give us a sense of your data. Assume that the listener knows what the statistical methods you are using are. Tell us what they say about your data. Emphasize the results more than the methods. Go slowly in the beginning so that the listener really understands what your data are.Rule 6: Speculate and generalize but use careful language. Say "It seems" or "appears" rather than "is" when it comes to speculative statements or models. For example, you might say "The residuals appear approximately normal" or "a linear model seems to fit well" but not "The residuals are normal" or "The data come from a linear model".Rule 7: Start with an introduction explaining what your data are, how you got them, and why they are interesting (roughly 2 minutes), then show your results as clearly as possible, with figures preferred (roughly 3 minutes), and then conclude (roughly 2 minutes). In your conclusion, mention the limitations of your analysis and speculate about what might make a future analysis better, if you had infinite time. This might include collecting more data, or getting data on more variables, as well as more sophisticated statistical methods.For your written reports, rules 5-7 apply again. Replace "minutes" with "pages". Have just the text in the beginning, and then the figures at the end. Email your pdf document to me, at frederic@stat.ucla.edu , by Sun, Dec 14, 11:59pm.2. Vectors and matrices in C.You can just say double x[100] or double x[25][4], for example.In mypi2.c,    /* Calculate the first 100 terms in the approximation of pi. */  #include <R.h>  #include <Rmath.h>  void pi100 (double *y){    int i;    double x[100];    x[0] = 1.0;    y[0] = sqrt(6.0);    for(i = 1; i < 100; i++) {      x[i] = x[i-1] + pow(i+1.0,-2.0);      y[i] = sqrt(6.0 * x[i]);    }  }In R,    system("R CMD SHLIB mypi2.c")    dyn.load("mypi2.so")    a = .C("pi100",y=double(100))    plot(1:100,a$y,type="l",xlab="n",ylab="Approx. of pi")In mypi3.c,    /* Calculate 1*2*3 + 4*5*6 + ... + 28*29*30. */  #include <R.h>  #include <Rmath.h>  void weirdsum (double *y){    int i,j;    double x[10][3];    *y = 0.0;    for(i = 0; i < 10; i++) {      for(j = 0; j < 3; j++){        x[i][j] = 3*i + j + 1.0;      }      *y += x[i][0] * x[i][1] * x[i][2];    }  }In R,    system("R CMD SHLIB mypi3.c")    dyn.load("mypi3.so")    y = 1.0    a = .C("weirdsum",as.double(y))    aIf you want x to be an n by m matrix, where n and m are inputs, you can just do, for instance, in mypi4.c,  /* Calculate 1*2*3*...*m + (m+1)(m+2)...(2m) + ... + [(n-1)m+1][(n-1)m+2]...(nm). */  #include <R.h>  #include <Rmath.h>  void pi103 (double *y, int *n, int *m){    int i,j;    double x[*n][*m];    double a;        /* First define the matrix. */    for(i = 0; i < *n; i++) {	for(j = 0; j < *m; j++){	    x[i][j] = *m*i + j + 1.0;	}    }        /* Now multiply each row and add the product to y. */    *y = 0.0;    for(i = 0; i < *n; i++){	a = 1.0;	for(j = 0; j < *m; j++){	    a *= x[i][j];	}	*y += a;      }    } In R,    system("R CMD SHLIB mypi4.c")    dyn.load("mypi4.so")    y = 1.0    a = .C("pi103",as.double(y),as.integer(10),as.integer(3))    a[[1]]    ## to check,     prod(1:3)+prod(4:6)+prod(7:9)+prod(10:12)+    prod(13:15)+prod(16:18)+prod(19:21)+prod(22:24)+prod(25:27)+prod(28:30)    a = .C("pi103",result75=as.double(y),as.integer(8),as.integer(4))    a$y    prod(1:4)+prod(5:8)+prod(9:12)+prod(13:16)+    prod(17:20)+prod(21:24)+prod(25:28)+prod(29:32)Note that you have to say "y = as.double(y)" rather than just as.double(y) if you want to be able to call the result with a$y.To do this in R, you could do  n = 8  m = 4  x = matrix(1:(n*m),byrow=T,ncol=m)  y = apply(x,1,prod)  sum(y)What if you want to define a vector of length n, or a matrix with a dimension n, and n is not an input or a known integer but instead something that must be calculated inside your function, or something that changes as you go through your function? Then you need to do dynamic memory allocation. We will hopefully get to this later.3. Calling C functions from C.In mysd1.c,    /* Create a 10 x 4 matrix of integers and compute the sample SD of each row. */  /* Row 1 will be (1, 4, 9, 16). Row 2 will be (25, 36, 49, 64), etc. */  #include <R.h>  #include <Rmath.h>    double sd2(double *x, int n){    int i;    double xbar, b;    xbar = 0.0;    for(i = 0; i < n; i++){      xbar += x[i];    }    xbar = xbar/n;    b = 0.0; // b will be the sum of squared deviations    for(i = 0; i < n; i++){      b += pow(x[i] - xbar, 2);    }    return(pow(b/(n-1),0.5));    }  void rowsd (double *y){    int i,j;    double a;    double x[10][4];    for(i = 0; i < 10; i++) {      for(j = 0; j < 4; j++){        x[i][j] = pow(4*i + j + 1.0, 2);      }      y[i] = sd2(x[i], 4);    }  } In R,    system("R CMD SHLIB mysd1.c")    dyn.load("mysd1.so")    a = .C("rowsd",y=double(10))    a$y    ## to check it,    sd(c(1,4,9,16))    sd(c(25,36,49,64))4. Running C from terminal.In mypi5.c,    #include <stdio.h>  #include <math.h>  int main ( ){    int i;    float x,y,h;    printf("\n How many years old are you? ");    scanf("%d", &i);    printf("\n How long is the first side of your right triangle? ");    scanf("%f", &x);    printf("\n How long is the second side of your right triangle? ");    scanf("%f", &y);    h = sqrtf(x*x + y*y);    printf("\n You are %d years old and the hypotenuse is %f . \n", i, h);    return(i);  }In terminal on mac (or powershell on PC),  cd /Users/fredericschoenberg/Documents/2012/202aF12/CinR,  gcc mypi5.c -o mypi5.out    ./mypi5.out4. Reading in from a file.You first need a file pointer  FILE *fp;FILE is a structure that holds information about the file. Use FILE * to pass the information around by reference.  fp = fopen(filename, mode);filename is a string that holds the name of the file on disk (including a path like /cs/course if necessary).mode is a string representing how you want to open the file. Most often you'll open a file for reading ("r") or writing ("w").In data.txt,  1  14  5  37  7  2  1  100In readin1.c,    #include <stdio.h>  #include <R.h>  #include <Rmath.h>  void readssq (int *n){    /* Read in the first n terms in "data.txt"    and compute the sum of squares.    Write the output to "output.txt" */    FILE *myfile1, *myfile2;    int i;    float a1, a2;        a2 = 0.0;    myfile1 = fopen("data.txt", "r");    myfile2 = fopen("output.txt", "w");    for(i = 0; i < *n; i++){	fscanf(myfile1, "%f", &a1);	a2 += pow(a1, 2);    }    fclose(myfile1);    Rprintf("The sum of squares is %f \n", a2);    fprintf(myfile2, "%f \n", a2);    fclose(myfile2);  }In R,    system("R CMD SHLIB readin1.c")    dyn.load("readin1.so")    a = .C("readssq",as.integer(5))The input file that we are opening for reading ("r") must already exist, but the output file we are opening for writing ("w") does not have to exist. If it doesn't, it will be created. If this output file does already exist, its previous contents will be thrown away and lost.Use "a" for append to write something to the end of a file without losing its contents.In fprintf,Integer values use %d,Floating point values, i.e. decimals, use %f,%lf for double precision numbers,Single characters use %c,Character strings use %s.Coming up.## inputting and outputting matrices.## Generalized additive models.## Making R packages.## Calling R from C.## C++.## Calling C++ from R.